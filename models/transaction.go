package models

import (
	"bytes"
	"encoding/hex"
	"fmt"
	"math/big"

	"github.com/onflow/flow-go-sdk"

	"github.com/ethereum/go-ethereum/common"
	gethTypes "github.com/ethereum/go-ethereum/core/types"
	"github.com/ethereum/go-ethereum/rlp"
	"github.com/onflow/cadence"
	cdcCommon "github.com/onflow/cadence/runtime/common"
	"github.com/onflow/flow-go/fvm/evm/types"
)

type txEventPayload struct {
	BlockHeight             uint64 `cadence:"blockHeight"`
	BlockHash               string `cadence:"blockHash"`
	TransactionHash         string `cadence:"transactionHash"`
	Transaction             string `cadence:"transaction"`
	Failed                  bool   `cadence:"failed"`
	VMError                 string `cadence:"vmError"`
	TransactionType         uint8  `cadence:"transactionType"`
	GasConsumed             uint64 `cadence:"gasConsumed"`
	DeployedContractAddress string `cadence:"deployedContractAddress"`
	ReturnedValue           string `cadence:"returnedValue"`
	Logs                    string `cadence:"logs"`
}

func (tx *txEventPayload) IsDirectCall() bool {
	return tx.TransactionType == types.DirectCallTxType
}

// DecodeReceipt takes a cadence event for transaction executed and decodes it into the receipt.
func DecodeReceipt(event cadence.Event) (*gethTypes.Receipt, error) {
	if !IsTransactionExecutedEvent(event) {
		return nil, fmt.Errorf(
			"invalid event type for decoding into receipt, received %s expected %s",
			event.Type().ID(),
			types.EventTypeTransactionExecuted,
		)
	}

	var tx txEventPayload
	err := cadence.DecodeFields(event, &tx)
	if err != nil {
		return nil, fmt.Errorf("failed to cadence decode receipt: %w", err)
	}

	encLogs, err := hex.DecodeString(tx.Logs)
	if err != nil {
		return nil, fmt.Errorf("failed to hex decode receipt: %w", err)
	}

	var logs []*gethTypes.Log
	if len(encLogs) > 0 {
		err = rlp.Decode(bytes.NewReader(encLogs), &logs)
		if err != nil {
			return nil, fmt.Errorf("failed to rlp decode receipt: %w", err)
		}
	}

	receipt := &gethTypes.Receipt{
		BlockNumber:       big.NewInt(int64(tx.BlockHeight)),
		Type:              uint8(tx.TransactionType),
		Logs:              logs,
		TxHash:            common.HexToHash(tx.TransactionHash),
		ContractAddress:   common.HexToAddress(tx.DeployedContractAddress),
		GasUsed:           tx.GasConsumed,
		CumulativeGasUsed: tx.GasConsumed, // todo check
		EffectiveGasPrice: nil,            // todo check
		BlobGasUsed:       0,              // todo check
		BlobGasPrice:      nil,            // todo check
		TransactionIndex:  0,              // todo add tx index in evm core event
		BlockHash:         common.HexToHash(tx.BlockHash),
	}

	if tx.Failed {
		receipt.Status = gethTypes.ReceiptStatusFailed
	} else {
		receipt.Status = gethTypes.ReceiptStatusSuccessful
	}

	receipt.Bloom = gethTypes.CreateBloom([]*gethTypes.Receipt{receipt})

	return receipt, nil
}

// DecodeTransaction takes a cadence event for transaction executed
// and decodes it into a geth transaction. If the transaction was
// generated by a direct call, we also return it.
func DecodeTransaction(event cadence.Event) (
	FlowEVMTxData,
	error,
) {
	if !IsTransactionExecutedEvent(event) {
		return nil, fmt.Errorf(
			"invalid event type for decoding into receipt, received %s expected %s",
			event.Type().ID(),
			types.EventTypeTransactionExecuted,
		)
	}

	t := &txEventPayload{}
	err := cadence.DecodeFields(event, t)
	if err != nil {
		return nil, fmt.Errorf("failed to cadence decode transaction: %w", err)
	}

	encodedTx, err := hex.DecodeString(t.Transaction)
	if err != nil {
		return nil, fmt.Errorf("failed to decode transaction hex: %w", err)
	}

	var evmTxData FlowEVMTxData

	// check if the transaction data is actually from a direct call,
	// which is a special state transition in Flow EVM.
	if t.IsDirectCall() {
		directCall, err := types.DirectCallFromEncoded(encodedTx)
		if err != nil {
			return nil, fmt.Errorf("failed to rlp decode direct call: %w", err)
		}

		evmTxData = DirectCallTx{Call: directCall}

		return evmTxData, nil
	} else {
		tx := &gethTypes.Transaction{}
		if err := tx.UnmarshalBinary(encodedTx); err != nil {
			return nil, fmt.Errorf("failed to rlp decode transaction: %w", err)
		}
		evmTxData = GethTx{Tx: tx}

		return evmTxData, nil
	}
}

var TransactionExecutedEventType = (flow.EVMLocation{}).TypeID(nil, string(types.EventTypeTransactionExecuted))

func IsTransactionExecutedEvent(event cadence.Event) bool {
	return cdcCommon.TypeID(event.EventType.ID()) == TransactionExecutedEventType
}
